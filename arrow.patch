diff --git a/cpp/CMakeLists.txt b/cpp/CMakeLists.txt
index 9ac59e9..8c26ef0 100644
--- a/cpp/CMakeLists.txt
+++ b/cpp/CMakeLists.txt
@@ -678,7 +678,7 @@ if (ARROW_JEMALLOC)
   set(ARROW_STATIC_LINK_LIBS
     ${ARROW_STATIC_LINK_LIBS}
     ${ARROW_JEMALLOC_LINK_LIBS})
-elseif (NOT MSVC)
+elseif (NOT WIN32)
   # We need to separate this as otherwise CMake would mess with the library
   # linking order.
   set(ARROW_LINK_LIBS
diff --git a/cpp/cmake_modules/SetupCxxFlags.cmake b/cpp/cmake_modules/SetupCxxFlags.cmake
index 41d2668..61b20e5 100644
--- a/cpp/cmake_modules/SetupCxxFlags.cmake
+++ b/cpp/cmake_modules/SetupCxxFlags.cmake
@@ -67,6 +67,9 @@ if (MSVC)
 
   # Support large object code
   set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} /bigobj")
+elseif(WIN32)
+  add_definitions(-DARROW_EXPORTING)
+  add_definitions(-D_GLIBCXX_USE_CXX11_ABI=0)
 else()
   # Common flags set below with warning level
   set(CXX_COMMON_FLAGS "")
@@ -180,7 +183,10 @@ endif()
 
 if ("${COMPILER_FAMILY}" STREQUAL "gcc")
   # Without this, gcc >= 7 warns related to changes in C++17
-  set(CXX_ONLY_FLAGS "${CXX_ONLY_FLAGS} -Wno-noexcept-type")
+
+  if ("${COMPILER_VERSION}" VERSION_GREATER "6.0")
+          set(CXX_ONLY_FLAGS "${CXX_ONLY_FLAGS} -Wno-noexcept-type")
+  endif()
 endif()
 
 # Clang options for all builds
diff --git a/cpp/src/arrow/memory_pool.cc b/cpp/src/arrow/memory_pool.cc
index 34bd600..a0b381b 100644
--- a/cpp/src/arrow/memory_pool.cc
+++ b/cpp/src/arrow/memory_pool.cc
@@ -44,7 +44,7 @@ namespace {
 // (as of May 2016 64 bytes)
 Status AllocateAligned(int64_t size, uint8_t** out) {
 // TODO(emkornfield) find something compatible with windows
-#ifdef _MSC_VER
+#ifdef _WIN32
   // Special code path for MSVC
   *out =
       reinterpret_cast<uint8_t*>(_aligned_malloc(static_cast<size_t>(size), kAlignment));
@@ -124,11 +124,11 @@ class DefaultMemoryPool : public MemoryPool {
     DCHECK(out);
     // Copy contents and release old memory chunk
     memcpy(out, *ptr, static_cast<size_t>(std::min(new_size, old_size)));
-#ifdef _MSC_VER
+#ifdef _WIN32
     _aligned_free(*ptr);
 #else
     std::free(*ptr);
-#endif  // defined(_MSC_VER)
+#endif  // defined(_WIN32)
     *ptr = out;
 #endif  // defined(ARROW_JEMALLOC)
 
@@ -147,7 +147,7 @@ class DefaultMemoryPool : public MemoryPool {
 
   void Free(uint8_t* buffer, int64_t size) override {
     DCHECK_GE(bytes_allocated_, size);
-#ifdef _MSC_VER
+#ifdef _WIN32
     _aligned_free(buffer);
 #elif defined(ARROW_JEMALLOC)
     dallocx(buffer, MALLOCX_ALIGN(kAlignment));
diff --git a/cpp/src/arrow/util/cpu-info.cc b/cpp/src/arrow/util/cpu-info.cc
index 822fcae..241abee 100644
--- a/cpp/src/arrow/util/cpu-info.cc
+++ b/cpp/src/arrow/util/cpu-info.cc
@@ -54,6 +54,13 @@ using boost::algorithm::trim;
 using std::max;
 using std::string;
 
+void __cpuidex(int CPUInfo[4], int function_id, int subfunction_id) {
+  __asm__ __volatile__ (
+      "cpuid"
+      : "=a" (CPUInfo [0]), "=b" (CPUInfo [1]), "=c" (CPUInfo [2]), "=d" (CPUInfo [3])
+  : "a" (function_id), "c" (subfunction_id));
+}
+
 namespace arrow {
 
 bool CpuInfo::initialized_ = false;
diff --git a/cpp/src/arrow/util/io-util.cc b/cpp/src/arrow/util/io-util.cc
index 2071446..8f3f594 100644
--- a/cpp/src/arrow/util/io-util.cc
+++ b/cpp/src/arrow/util/io-util.cc
@@ -217,7 +217,7 @@ Status FileTell(int fd, int64_t* pos) {
 
 Status CreatePipe(int fd[2]) {
   int ret;
-#if defined(_MSC_VER)
+#if defined(_WIN32)
   ret = _pipe(fd, 4096, _O_BINARY);
 #else
   ret = pipe(fd);
@@ -296,7 +296,7 @@ Status FileGetSize(int fd, int64_t* size) {
 //
 
 static inline int64_t pread_compat(int fd, void* buf, int64_t nbytes, int64_t pos) {
-#if defined(_MSC_VER)
+#if defined(_WIN32)
   HANDLE handle = reinterpret_cast<HANDLE>(_get_osfhandle(fd));
   DWORD dwBytesRead = 0;
   OVERLAPPED overlapped = {0};
